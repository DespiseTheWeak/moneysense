#include "Fakelag NEW.h"
#include "PWalk.h"
#include "autodefuser.exe.h"

void MinWalk(CUserCmd* get_cmd, float get_speed)
{
	//removed
}

void pwalk::CreateMovementwithBlackPeopleThrowingCoalIntoMyOven(CUserCmd* get_cmd) {
	if (g_cfg.fastwalk.enabled)
	{
		//removed
	}
}
void autodefuser::defuserapplication(CUserCmd* cmd) {
	if (!g_cfg.misc.autodefuse)
		return;
	if (!g_ctx.m_local || !g_ctx.m_local->is_alive())
		return;
	if (g_ctx.m_local->m_iTeamNum() != 3)
		return;
	CCSBomb* bomb = nullptr;
	for (int i = 1; i < g_csgo.m_entitylist()->GetHighestEntityIndex(); i++)
	{
		IClientEntity* entity = g_csgo.m_entitylist()->GetClientEntity(i);
		if (!entity)
			continue;
		if (entity->GetClientClass()->m_ClassID == ClassId::CPlantedC4)
		{
			bomb = (CCSBomb*)entity;
			break;
		}
		if (!bomb || bomb->m_bBombDefused())
			return;
		float flBlow = bomb->m_flC4Blow();
		float lifetime = flBlow - (g_csgo.m_globals()->m_interval_per_tick * g_ctx.m_local->m_nTickBase());
		if (g_ctx.m_local->m_bHasDefuser() && lifetime > 5.5f)
			return;
		if (!g_ctx.m_local->m_bHasDefuser() && lifetime > 10.5f)
			return;
		if (bomb->m_bBombDefused())
			return;
		float distance = g_ctx.m_local->m_vecOrigin().DistTo(bomb->GetAbsOrigin());
		if (distance <= 75.0f)
			cmd->m_buttons |= IN_USE;
	}
}
int fakelag::BreakLagCompensation()
{
	float speed = g_ctx.m_local->m_vecVelocity().Length2D();
	if (speed > 0.f)
	{
		auto distance_per_tick = speed * g_csgo.m_globals()->m_interval_per_tick;
		int choked_ticks = std::ceilf(65.f / distance_per_tick);
		return std::min<int>(choked_ticks, 14);
	}
}
int fakelag::BreakLagCompensation_low()
{
	float speed = g_ctx.m_local->m_vecVelocity().Length2D();
	if (speed > 0.f)
	{
		auto distance_per_tick = speed * g_csgo.m_globals()->m_interval_per_tick;
		int choked_ticks = std::ceilf(65.f / distance_per_tick);
		return std::min<int>(choked_ticks, 2);
	}
}
void fakelag::Fakelag(CUserCmd *pCmd)
{
	weapon_t* pWeapon = (weapon_t*)g_csgo.m_entitylist()->GetClientEntityFromHandle(g_ctx.m_local->m_hActiveWeapon());
	float yAs = 100;
	if (!g_csgo.m_engine()->IsConnected() || !g_csgo.m_engine()->IsInGame()) return;
	if ((pCmd->m_buttons & IN_USE) || g_ctx.m_local->get_move_type() == MOVETYPE_LADDER) return;
	if (pWeapon->is_grenade()) return;
	if (pWeapon->m_iItemDefinitionIndex() == (short)ItemDefinitionIndex::WEAPON_REVOLVER)
	{
		memereview = !memereview;
		if (memereview) g_ctx.send_packet = true;
		else g_ctx.send_packet = false;
	}
	auto anime = &g_ctx.m_local->GetAnimOverlays()[1];
	static auto choked = 0;
	static int tick; tick++;
	static int factor = 7;
	const auto max_fake_lag3 = g_cfg.antiaim.fakelag_amountstanding;
	const auto max_fake_lag = g_cfg.antiaim.breaklagcomp ? BreakLagCompensation() : g_cfg.antiaim.fakelag_amountmoving;
	const auto max_fake_lag2 = g_cfg.antiaim.breaklagcomp ? BreakLagCompensation() : g_cfg.antiaim.fakelag_amountinair;
	float flVelocity = g_ctx.m_local->m_vecVelocity().Length2D() * g_csgo.m_globals()->m_interval_per_tick;
	if ((pCmd->m_buttons & IN_ATTACK && g_cfg.antiaim.fl_spike_on_shoot)
		|| (fabs(g_ctx.m_local->m_vecVelocity().z) <= 5.0f  && g_cfg.antiaim.fl_spike_on_jump)) {
		if (choked < 15)
		{
			choked++;
			g_ctx.send_packet = false;
		}
		else
		{
			choked = 0;
			g_ctx.send_packet = true;
		}
	}
	else if (g_ctx.m_local->m_vecVelocity().Length2D() > 0.01 && g_ctx.m_local->m_vecVelocity().Length2D() < 120.f
		&& g_cfg.antiaim.fl_spike_on_peek && (g_ctx.m_local->m_fFlags() & FL_ONGROUND) && (!(fabs(g_ctx.m_local->m_vecVelocity().z) <= 1.0f)))
	{
		g_ctx.send_packet = !(tick % factor);
		if (g_ctx.send_packet)
		{
			factor = clamp(static_cast<int>(std::ceil(69.f / flVelocity)), 1, 15);
			factor = clamp(static_cast<int>(std::ceil(64.f / g_ctx.m_local->m_vecVelocity().Length2D())), 1, 15);
		}
	}
	else
	{
		if (choked < max_fake_lag && g_ctx.m_local->m_vecVelocity().Length2D() >= 1 && (g_ctx.m_local->m_fFlags() & FL_ONGROUND))
		{
			choked++;
			g_ctx.m_globals.fakelagamt = choked;
			g_ctx.send_packet = false;
		}
		else if (choked < max_fake_lag2 && g_ctx.m_local->m_vecVelocity().Length2D() >= 1 && !(g_ctx.m_local->m_fFlags() & FL_ONGROUND))
		{
			choked++;
			g_ctx.m_globals.fakelagamt = choked;
			g_ctx.send_packet = false;
		}
		else if (choked < max_fake_lag3 && g_ctx.m_local->m_vecVelocity().Length2D() < 1)
		{
			choked++;
			g_ctx.m_globals.fakelagamt = choked;
			g_ctx.send_packet = false;
		}
		else
		{
			choked = 0;
			g_ctx.m_globals.fakelagamt = choked;
			g_ctx.send_packet = true;
		}
	}
}
bool fakelag::fakelag_conditions(CUserCmd * cmd)
{
	weapon_t* pWeapon = (weapon_t*)g_csgo.m_entitylist()->GetClientEntityFromHandle(g_ctx.m_local->m_hActiveWeapon());

	float fl_speed = g_ctx.m_local->m_vecVelocity().Length2D();
	float fl_vel = g_ctx.m_local->m_vecVelocity().Length2D() * g_csgo.m_globals()->m_interval_per_tick;
	float dmg = 0.f;
	if (fl_speed > 1 && (g_ctx.m_local->m_fFlags() & FL_ONGROUND) && !(cmd->m_buttons & IN_ATTACK))
	{
		return true;
	}
	if (cmd->m_buttons & IN_ATTACK)
	{
		return true;
	}
	if (fabs(g_ctx.m_local->m_vecVelocity().z) <= 5.0f && !(g_ctx.m_local->m_fFlags() & FL_ONGROUND))
	{
		return true;
	}
	return false;
}
void fakelag::fakelag_auto(CUserCmd *pCmd)
{
	weapon_t* pWeapon = (weapon_t*)g_csgo.m_entitylist()->GetClientEntityFromHandle(g_ctx.m_local->m_hActiveWeapon());
	static auto choked = 0;
	if (!g_csgo.m_engine()->IsConnected() || !g_csgo.m_engine()->IsInGame()) return;
	if ((pCmd->m_buttons & IN_USE) || g_ctx.m_local->get_move_type() == MOVETYPE_LADDER) return;
	static int tick; tick++;
	static int factor = 7;
	float fl_speed = g_ctx.m_local->m_vecVelocity().Length2D();
	float fl_vel = g_ctx.m_local->m_vecVelocity().Length2D() * g_csgo.m_globals()->m_interval_per_tick;
	const auto break_fl = BreakLagCompensation_low();
	const auto break_fl_2 = BreakLagCompensation();
	if (pWeapon->is_grenade() || pWeapon->m_iItemDefinitionIndex())
	//if (pWeapon->is_grenade() || pWeapon->m_iItemDefinitionIndex() == (short)ItemDefinitionIndex::WEAPON_REVOLVER)
	{
		if (choked < 1)
		{
			choked++;
			g_ctx.send_packet = false;
			g_ctx.m_globals.fakelagamt = choked;
		}
		else
		{
			choked = 0;
			g_ctx.m_globals.fakelagamt = choked;
			g_ctx.send_packet = true;
		}
	}
	else
	{
		if (g_csgo.m_clientstate()->m_nChokedCommands > 0 && fakelag_conditions(pCmd) && g_csgo.m_clientstate()->m_nChokedCommands < 15)
		{
			g_ctx.send_packet = true;
		}
		else if (!(g_ctx.m_local->m_fFlags() & FL_ONGROUND))
		{
			if (choked < break_fl_2)
			{
				choked++;
				g_ctx.m_globals.fakelagamt = choked;
				g_ctx.send_packet = false;
			}
			else
			{
				choked = 0;
				g_ctx.m_globals.fakelagamt = choked;
				g_ctx.send_packet = true;
			}
		}
		else
		{
			if (fl_speed > 0.1f)
			{
				if (choked < break_fl_2)
				{
					choked++;
					g_ctx.m_globals.fakelagamt = choked;
					g_ctx.send_packet = false;
				}
				else
				{
					choked = 0;
					g_ctx.m_globals.fakelagamt = choked;
					g_ctx.send_packet = true;
				}
			}
			else
			{
				if (choked < 2)
				{
					choked++;
					g_ctx.m_globals.fakelagamt = choked;
					g_ctx.send_packet = false;
				}
				else
				{
					choked = 0;
					g_ctx.m_globals.fakelagamt = choked;
					g_ctx.send_packet = true;
				}
			}
		}
	}
}

void fakelag::Createmove() {
	auto weapon = g_ctx.m_local->m_hActiveWeapon().Get();
	if (!weapon)
		return;

	bool should_fakelag = false;

	int
		tick_times = ((int)(1.0f / g_csgo.m_globals()->m_interval_per_tick)) / 64,
		choke;

	switch (g_cfg.antiaim.fakelag_mode) {
	case 0:
		choke = min(g_cfg.antiaim.fakelag_amount * tick_times, 14);
		break;
	case 1:
		choke = math::clamp(static_cast<int>(std::ceilf(69 / (g_ctx.m_local->m_vecVelocity().Length() * g_csgo.m_globals()->m_interval_per_tick))), 1, 14);
		break;
	}

	if (g_cfg.antiaim.fakelag_enablers[FAKELAG_AIR].enabled) {
		if (!(g_ctx.m_local->m_fFlags() & FL_ONGROUND))
			should_fakelag = true;
	}

	if (g_ctx.m_local->m_vecVelocity().Length() > 0 && g_ctx.m_local->m_fFlags() & FL_ONGROUND) {
		if (g_cfg.antiaim.fakelag_enablers[FAKELAG_MOVING].enabled)
			should_fakelag = true;

		if (g_cfg.antiaim.fakelag_onpeek) {
		}
	}

	if (g_cfg.antiaim.fakelag_enablers[FAKELAG_SHOOTING].enabled) {
		if (g_ctx.get_command()->m_buttons & IN_ATTACK && weapon->can_fire())
			should_fakelag = true;
	}

	if (g_cfg.antiaim.fakelag_enablers[FAKELAG_STANDING].enabled) {
		if (g_ctx.m_local->m_fFlags() & FL_ONGROUND && !g_ctx.m_local->m_vecVelocity().Length())
			should_fakelag = true;
	}

	if (!g_cfg.antiaim.fakelag_enablers[FAKELAG_SHOOTING].enabled) {
		if (g_ctx.get_command()->m_buttons & IN_ATTACK && weapon->can_fire())
			should_fakelag = false;
	}

	if (g_ctx.m_globals.fakewalking)
		return;

	if (should_fakelag) {
		static int choked = 0;

		if (choked > choke) {
			g_ctx.send_packet = true;
			choked = 0;
		}
		else {
			g_ctx.send_packet = false;
			choked++;
		}

		g_ctx.m_globals.fakelagging = true;
	}
}

/*void fakelag::Createmove(CUserCmd *pCmd) {
	if (!g_ctx.m_local || !g_csgo.m_engine()->IsConnected() || !g_csgo.m_engine()->IsInGame() || g_ctx.m_local->m_iHealth() <= 0.f || g_ctx.m_globals.fakewalking) return;
	if (g_cfg.antiaim.auto_fakelag) fakelag_auto(pCmd);
	if (!g_cfg.antiaim.auto_fakelag) Fakelag(pCmd);
	if (g_cfg.lagspike.enabled)
	{
		auto weapon = g_ctx.m_local->m_hActiveWeapon().Get();
		if (!weapon) return;
		static int nCount = 0;
		float m_flOldFrametime;
		if (g_ctx.get_command()->m_buttons & IN_ATTACK && weapon->can_fire()) return;
		if (g_csgo.m_inputsys()->IsButtonDown(g_cfg.lagspike.key))
		{
			static int Choked = -1;
			Choked++;
			if (Choked < 3)
			{
				g_ctx.send_packet = false;
				g_ctx.get_command()->m_tickcount += 10;
				Choked += 7 + g_ctx.get_command()->m_tickcount % 2 ? 0 : 1;
			}
			else
			{
				g_ctx.send_packet = false;
				Choked = -1;
				m_flOldFrametime = g_csgo.m_globals()->m_frametime *= (g_ctx.m_local->m_vecVelocity().Length2D()) / 1.f;
			}
			if (nCount++ > 100)
			{
				g_ctx.send_packet = true;
				nCount = 0;
			}
		}
	}
}*/